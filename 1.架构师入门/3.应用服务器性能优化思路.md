# 使用集群

## 并行和并发
- 同一刻时间点进行的两个任务的是并行，互相不抢cpu资源
- 并发是每个任务被拆分成细小的任务片，被轮番执行，同一时间段只有一个任务片执行，互相抢cpu资源
- 在架构设计上，把并行和并发都称为并发
## 集群整体并发
- 用户激增时，通过负载均衡(有很多组件)，构建服务器集群，将并发分发到不同服务器，服务器配置尽量形同
- 有顺序的请求时，会出现数据不同的情况，如发送的请求是，A修改，B查询，A和B分配到两台服务器，那么有可能B返回了，A还没返回，
## 无状态节点集群
- 用来解决有顺序的请求，
- 没有特殊状态的，请求自身携带服务端需要的参数，服务器不存和请求相关的东西
- 几乎不变的模板类的东西
- 服务器不存储session就是无状态的
- 连接公共的存储
场景：集群服务器中，如果需要执行定时的任务，
- 任务加锁
- 判断是否执行过
- 外部服务唤醒定时任务，外部唤醒哪台机器去执行
## 单一服务节点集群
- 用户知道上下文的状态，玩游戏的进度，装备的情况，买装备，卖装备
- 这些状态不能存数据库，玩游戏时选择不同的服务，数据没有放在公共的存储上，
- 实时对战类是长连接，长连接实时效率高
- 把数据存储到每个服务器的内存上，每个用户对应某个服务器，每个服务器保存了用户的信息，服务某个用户的是单一服务器
- 手动选择在用户注册时选择节点，自动选择根据用户id情况分配服务器(id/服务器数取余数)，把该用户的所有请求分流到选择的服务器，各节点无法备份，某节点宕机，该节点服务的用户就没办法使用了
- 实际应用中，很少使用该方案
- 特定用户在特定服务器处理的场景
## 信息共享节点集群
- 所有服务器节点连接到公共的信息池，可以是db，文件，缓存等等
- 服务和信息池在不同服务器上
- 公共数据要加锁，或判断是否已修改
- 优点：server扩展方便
- 缺点：公共信息池越大，增删改查速度慢，服务扩大的时候，信息池就会成为瓶颈
- ![[4834918f-608c-45ba-b5c6-572536107998.png]]
## 信息一致节点集群
- 为了解决信息共享的缺点，而产生的新的架构模式
- ![[cc598ce2-3973-4981-8054-c323ae968764.png]]
- 每个服务节点有自己的数据池，每个数据池之间的数据结构和数据都是相同的
- 怎样解决分布式数据一致性问题，节点间的信息不同步，或存在信息延迟？
- 有两种方案：强一致性，弱一致性（最终一致性）
- CAP定理，（可用中间件的设计，业务的设计），
- 节点组成的网络是互通的，出现网络故障时，节点间不通了，数据散落在不同区域（每个区域有几个节点）中，这就是P，容错是允许节点间不通了，业务能继续执行，数据可以不准确，如果系统断了，业务执行不了，那就是不允许分区容错了
-  C一致性(写和读必须保证一致)，A可用性，P分区容错性
- 当数据只在一个节点中保存，出现了区域（节点不连通）情况时，和这个几点不连通的部分，就访问不到数据，这个时候分区是无法容忍的
- 保证P(分区容错性)的办法，就是冗余，就是将某个节点的数据复制到所有节点，每次写操作都要等待所有数据节点处理完，这就是保证一致性问题，等待的过程中，又会产生可用性的问题，当某个数据节点同步其它节点的数据时，要锁住该节点，不让其他人使用，就会带来可用性的问题，节点越多，容忍性越高，这就引起cap不能同时满足，设计系统时，必须有所平衡，只能选取三个特性中的两个
- 必须要保证P，就是网络断了，应用程序也能服务，所以只能在A和C中做选择
- 三选二挑一，三个特性中选择两个，还重点保证一个
- 强一致性，就是写操作后，后续所有读操作都是最新值，保证了一致性，就牺牲了可用性，
- 弱一致性，写操作后，后续读操作，有可能会出现不是最新值的，或通过一段时间后再全部更新
- 最终一致性用的比较广
### CAP场景
- 银行系统对一致性要求高
- 电商系统对可用性要求高，最新的图片晚点看到也可以
- 订单支付中这个状态，就是属于弱一致
### 网络的8大错误
总之一点：网络不可靠，有各种问题
- 网络总是可靠的，软硬件有问题，配置被修改了，停电了
- 没有延迟，有距离，有速度，必然需要时间
- 带宽无限，带宽是收费的
- 网络总是安全的，有病毒，有攻击，代码被暴露
- 网络拓扑不变，部署好的节点，随着用户量增大，业务一直运营，就会有变化的
- 只有一个管理员，可能有多个云管理员
- 传输代价为0
- 网络是同构的，网络连接中每个设备的网络硬件模块不同，所以协议等等都是不同的，不同厂商，不同运营商
### 总结
如何取舍？
- 保证可用性，分区容错性，舍弃强一致（保证弱一致性）
- 弱一致性：把数据抛到消息队列中，消费失败，就要有重试的功能，就会出现短暂不一致的情况，根据业务情况决定
- 信息一致性尽量读多写少，避免信息不一致，发挥信息池高吞吐量的优势
## 服务内并发
### 多进程
1. 进程之间有隔离性，某进程崩溃，不影响其它进程，
2. 服务器资源有限的情况下，可以给同一个服务多开几个，但是端口不同即可，每个服务占用的资源不同，比如A服务占用cpu多，B服务占用内存多，
### 多线程
1. 线程数的选择：没有准确的数字
2. 场景：打车计费，时长有一种计费方式，里程有一种计费方式，可以多线程同时计算时长计费&里程计费
3. 为了实现并发，提升效率，实现异步
4. 实现异步场景：长任务，耗时特别长，对服务器造成压力，影响前端响应时长，用户不友好
5. 副线程：日志，信息上报与统计，与第三方交互
### 多协程
1. jdk19中才可开始使用

## 线程数
### 线程数计算
1. 没有准确的数字
2. 但是通过一个大概的公式也可以计算
3. 《java编程实践》线程数=cpu核数×cpu的利用率×(1+w/c)
4. cpu利用率：处理器正在执行任务的时间百分比，CPU的计算时间(CPU忙的时间)/CPU的总时间，如1秒钟忙了0.5秒，利用率就是50%，1分钟内忙了20秒，20/60=利用率就是33%，如果两核的，其中一个1分钟内忙了5秒，另一个1分钟内忙了30秒，就是(30+5)/120(2个1分钟)=29%
5. 计算线程数时，假设cpu利用率是100%的，实际生产服务器的CPU利用率建议是70%，第一步先拿100%计算，
6. linux命令：top可以查cpu利用率，loadaverage：1.0(1分钟)，1.1(1分钟)，1.2(1分钟)
7. 当loadaverage第一个数持续大于核数×利用率0.7，需要调查原因
8. 当loadaverage第一个数持续大于核数时，需要停掉一些不用的服务
9. 当loadaverage第一个数持续大于5倍的核数时，该节点就会死机了
10. 当loadaverage三个数持续相同时，该节点运行平稳，但需要对比昨天，一周前，一月前同时段的数据是否相同，
11. 当loadaverage第一个小于后面的数时，说明高峰过去了
12. w是等待时间，c是计算时间
13. 参考值：假设2核，cpu利用率是100%，等待时间是2，计算时间是1，则线程数=6
14. 等待时间比上计算时间的数大，线程数就多
15. 执行一段代码时，打印计算前后的时间
16. IO密集型：等待时间比计算时间大，保守把w/c设置成1
17. 计算密集型：等待时间比计算时间小，保守把w/c设置成0
18. 实际工作中，可以去服务器上测试等待时间和计算时间