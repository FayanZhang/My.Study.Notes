**整体优化思路**
1.大事化小，把服务分类等，集群，分库分表，负载均衡，分区，读写分离
2.前置处理，加缓存
3.后置处理，加消息队列中
4.加快处理，代码优化，多线程，利用CPU、内存等等

优化范围：从用户使用我们系统开始，到我们响应用户为止

**前端优化**
整体思路：能前端做前端做，减少和后端的交互。

1.减少不必要的传输，每个链接总是访问很多资源，访问很多后端接口，
1).减少传递的次数
2).减少传递时携带的数据量
3).合并http请求：合并js，css，图片，chrome同时允许6个请求，火狐是8个请求
表现形式：客户端==>??资源,资源，服务端==>nginx：nginx-http-concat-master，tengine：mod_concat
4).启用压缩: 
有利有弊：资源在服务端压缩，客户端解压缩，影响服务端CPU和内存
客户端：accept-encoding，默认启用解压缩
服务端：content-encoding，默认启用压缩
图片显示缩略图
图片转base64：做为文本传输
5).减少cookie: 静态资源单独放到一个域名下。
6).斟酌顺序：下载完全部css后，才对页面进行渲染，将CSS放在页面最上面，尽快下载css
下载完某个js后，会马上执行，影响css展示，造成页面阻塞，js放在页面最下面，如果页面解析时，用到某些js时，可以放到前面

2.该前置的前置
1).利用客户端计算的能力
预估的价格，时间等等的

3.该缓存的缓存
数据不经常变动的，缓存到客户端
1).http缓存：减少资源下载的次数，response header：cache-control
public(响应)：从客户端到服务端的路径上，都可以缓存，共享和私有缓存
private(响应)：只有客户端可以缓存，路径上的其它节点不可以缓存
no-cache(请求、响应)：都可以缓存，但不能用
no-store(请求、响应)：任何设备不能缓存，
有效时长：
max-age=秒，s-maxage=秒，max-stale=秒，min-fresh=秒
重新验证：
must-revalidate(响应)，proxy-revalidate(共享)
其它：
no-transform，only-if-cached
解决缓存过期的思路：
更改文件名
后端验证缓存的有效性last-modified、if-modified-since
etag、if-none-match
2).客户端缓存：
数据缓存在浏览器的数据库中，
storage(localstorage、sessionstorage、indexdb、websql)，cache(cachestorage)
只和当前用户有关的数据
不要存储私密信息

**DNS优化**
