# 整体优化思路

1.大事化小，把服务分类等，集群，分库分表，负载均衡，分区，读写分离
2.前置处理，加缓存
3.后置处理，加消息队列中
4.加快处理，代码优化，多线程，利用CPU、内存等等

优化范围：从用户使用我们系统开始，到我们响应用户为止
# 前端优化

整体思路：能前端做前端做，减少和后端的交互。
## 减少不必要的传输

每个链接总是访问很多资源，访问很多后端接口，

1.减少传递的次数
2.减少传递时携带的数据量
3.合并http请求：合并js，css，图片，chrome同时允许6个请求，火狐是8个请求
表现形式：客户端==>??资源,资源，服务端==>nginx：nginx-http-concat-master，tengine：mod_concat
4.启用压缩: 
有利有弊：资源在服务端压缩，客户端解压缩，影响服务端CPU和内存
客户端：accept-encoding，默认启用解压缩
服务端：content-encoding，默认启用压缩
图片显示缩略图
图片转base64：做为文本传输
5.减少cookie: 静态资源单独放到一个域名下。
6.斟酌顺序：下载完全部css后，才对页面进行渲染，将CSS放在页面最上面，尽快下载css
下载完某个js后，会马上执行，影响css展示，造成页面阻塞，js放在页面最下面，如果页面解析时，用到某些js时，可以放到前面
## 该前置的前置

1.利用客户端计算的能力
预估的价格，时间等等的
## 该缓存的缓存

数据不经常变动的，缓存到客户端
1.http缓存：减少资源下载的次数，response header：cache-control
public(响应)：从客户端到服务端的路径上，都可以缓存，共享和私有缓存
private(响应)：只有客户端可以缓存，路径上的其它节点不可以缓存
no-cache(请求、响应)：都可以缓存，但不能用
no-store(请求、响应)：任何设备不能缓存，
有效时长：
max-age=秒，s-maxage=秒，max-stale=秒，min-fresh=秒
重新验证：
must-revalidate(响应)，proxy-revalidate(共享)
其它：
no-transform，only-if-cached
解决缓存过期的思路：
更改文件名
后端验证缓存的有效性last-modified、if-modified-since
etag、if-none-match
2.客户端缓存：
数据缓存在浏览器的数据库中，
storage(localstorage、sessionstorage、indexdb、websql)，cache(cachestorage)
只和当前用户有关的数据
不要存储私密信息
# DNS优化

1.DNS既是域名解析系统：域名和ip的映射
A:address 域名->IP
CNAME 域名->域名
NSNAME 域名->域名解析服务器

2.域名服务器的类型
根域名服务器：A-M共13个，
权威域名服务器：
本地DNS(LDNS)：和客户端对接的
nslookup

3.DNS解析过程：
理论：比如查某个com域名的IP过程
LDNS->从根域名->.com域名->权威域名->NS.XX.com->可能给出地址，也可能给了一个其它权威域名服务器

4.实际解析：
client->先看浏览器是否有缓存->操作系统是否有缓存->host文件是否有缓存->LDNS是否有缓存->.com服务器->

5.优化方案：
1).提前做好DNS缓存
接口尽量用同一个域名，
预获取 dns prefech，访问A的时候，同时解析B使用的域名
打开预解析<meta http-equiv="x-dns-prefetch-control" content="on"/>
<meta rel="dns-prefech" href="预解析的域名"/>慎用(行业内协定)，浪费公共资源
2).一个域名可以映射多个IP，用dns做第一次负载均衡，用反向代理再做负载均衡

6.dns优化的优缺点
优点：无成本费用
缺点：不受控制，不能按需分配负载
# CDN优化
内容网络分发：是一种通过**在全球各地部署缓存服务器**来加速网站内容访问的技术。它的核心目标是**让用户从离自己最近的服务器获取数据，从而提升访问速度和可靠性**

1.各地部署多个节点，多个请求分配到不同服务器上，
2.每个客户端都就近请求，降低网络延时，减少用户响应时间

把静态资源部署到每台服务器
核心程序放服务器少一些
## 核心概念

**内容分发**：把网站的静态内容（如图片、视频、CSS、JS 文件）复制到多个节点服务器。
**就近访问**：用户访问时，CDN 会把请求路由到**距离最近的节点**，而不是远程源站服务器。
**减轻源站压力**：源站服务器不必直接处理所有用户请求，提高稳定性。

CDN结构：源站(根节点，静态资源和程序等，源站也可能有多个），cdn节点（缓存节点，边缘节点，静态资源）
边缘节点是源站的部分资源的备份

大公司在做CDN的服务商，减少系统并发数，分担源站的压力，减少平均响应时间，减少网络拥堵

CDN内容：静态资源

CDN原理：分析用户的请求，看边缘节点是否有，有就返回，没有就去源站获取，并缓存到边缘节点，类似注册中心
## CDN 的工作原理（简化版）
用户请求资源（如图片或网页）。
DNS 或 CDN 系统判断用户位置，将请求指向**最近的 CDN 节点**。
节点检查自己是否有缓存：
- 有 → 直接返回缓存内容（快速）。
- 没有 → 向源站服务器拉取内容，然后缓存起来再返回。
用户收到内容，加载速度更快。

用户请求->LDNS->CDN服务商的域名->分析来源，如果来源是某地->返回某地CDN节点的IP地址->CDN节点有缓存则返回->无则去源站请求
![[image 20251114102333.png]] 
## CDN 常见用途
- 静态资源加速：图片、视频、JS、CSS、字体文件。
- 动态内容加速：一些高级 CDN 支持动态内容缓存和优化。
- 视频点播和直播加速。
- API 请求优化（通过边缘节点加速数据传输）。
- 安全防护（防 DDoS、防盗链、防爬虫等）。
## CDN扩展：多地址直连
源站：动态内容，让客户端分发到合适的源站
1.类注册中心
2.类规则中心

![[image 20251114150203.png]]

注册中心和规则中心，处理简单的地址信息请求，给客户端提供一个源站IP，实际取数据，是从源站获取的

类似的场景：
1.mvn的respository文件，把下载源备份到本地了
2.游戏登录时，选服务器
# 代理

![[image 20251114151119.png]]

正向代理：用户端设置代理服务器，所有的请求都由代理服务器发出，无法判断代理的多少
![[image 20251114151732.png]]

反向代理：服务端配置代理
![[image 20251114151947.png]]
实现方法：
1.OSI的第四层反向代理、第七层反向代理
第七层代理可以根据图片，css，js等文件类型、请求类型等进行转发，所以更智能
第四层代理可以根据IP、端口进行转发，所以效率高
![[image 20251114153947.png]]
代理的上游
![[image 20251114154024.png]]
# 伸缩性思考
1.不需要改变网站的软硬件设计，仅仅通过改变的部署的服务器数量，就可以扩大或缩小网站的服务处理能力，以上DNS、CDN、代理就是做伸缩用
2.增加和减少服务器数量，就是伸缩性
3.用DNS，同一个域名不同的IP地址(域名的集群)，可以用负载均衡算法，返回不同的IP地址，缺点是DNS有很多服务器，不及时更新记录，有可能请求分发到已下线的服务器了，一般公司是通过DNS解析，返回反向代理的服务器，
![[1b3c5609-ba92-4906-918e-972b11993592.png]]
4.反向代理，绝大多数反向代理服务器提供负载均衡，代理服务器提供内网和外网的地址，缺点是请求和返回都通过这台服务器，性能就是整个架构的瓶颈
![[0ce9d546-5398-4ff5-89ac-8a340cb99312.png]]
5.HTTP重定向，根据用户的http请求，访问重定向服务器地址，返回给客户端一个IP，且状态码是302，客户端根据拿到重定向的IP，再去请求真实的服务器
优点：请求转发，浏览器的web地址有变化
http重定向，web地址不变
缺点：浏览器需要两次请求，重定向服务器的性能成为瓶颈，返回的302码，降低搜索排名，实战中用此方式不多，业内也不提倡
![[077638db-3915-4052-867f-e34e70970c9f.png]]
6.IP层负载均衡
snat：源地址转换
缺点：受限于负载均衡的网卡
![[b3848646-51e2-4aef-a7e5-7ee6d265348e.png]]
7.数据链路层进行mac地址修改(三角传输模式、数据链路层负载均衡、直接路由方式DR)
在大型网站常用，linux常用的LVS
![[a17f661f-3272-4e0a-8539-a3406bd6033c.png]]
后端服务器和负载均衡服务器对外的IP是相同的，负载均衡服务器在请求时把数据链路层的mac地址改了，
## 伸缩性的思考：负载均衡算法
1.轮询：RR round robin，按照顺序发
场景：每个服务器的配置是相同的
有一个数组保存服务器的IP，每次来取数组索引
2.加权轮询：weighted round robin，权重不同
场景：给服务器分配权重，如A服务器的权重是6，B服务器的权重是4
取随机数，如果是0-5就分配到A服务器，6-9就分配到B服务器，不能保证权重是相同的，大概率是没问题的
3.随机：取随机数，随机取索引
4.最少链接：服务器的连接数在负载均衡服务器里面做了记录
5.源地址散列：source hashing，根据请求来源的ip地址进行哈希计算，源地址不变，请求的服务器的ip也不变，针对请求的ip进行md5的哈希计算，有利于session的维护
# 网关
1.位置：反向代理后面，有可能在nginx前或后，或公司自研网关，微服务中的gateway，也可以做负载均衡
2.协议转换，路由转发，负载均衡，安全保障
3.double转换成restful协议
4.路由转发，避免前端修改地址，重新发版本
5.对外的唯一出入口
## XSS
攻击者通过在网站注入恶意脚本（通常是 JavaScript），让访问网站的用户在不知情的情况下执行这些脚本，从而达到窃取信息、篡改页面或执行其他操作的目的。

|类型|特点|示例用途|
|---|---|---|
|**反射型（Reflected XSS）**|恶意脚本随 URL 或表单输入直接被返回并执行|钓鱼链接 → 诱导用户点击|
|**存储型（Stored XSS）**|恶意脚本被存储在服务器（如数据库、留言板）并被其他用户访问时执行|论坛或评论区植入脚本 → 所有访问者中招|
|**DOM 型（DOM-based XSS）**|攻击利用前端 JavaScript 操作 DOM 的漏洞执行脚本|URL 参数被前端 JS 直接插入页面 → 执行脚本|

反射型：网页嵌入恶意脚本，点击后进行攻击，攻击局部
持久型：通过黑客提交恶意脚本的请求，脚本放在服务器上，危害大
### 防御方法

1. **输入过滤/输出转义**
    - 对 `<`, `>`, `&`, `"` 等字符进行 HTML 转义。
2. **内容安全策略（CSP）
    - 限制页面可执行的脚本来源。
3. **避免在 HTML 中直接插入用户输入**
    - 尽量使用安全模板或前端框架（React、Vue 等默认防 XSS）。
4. **Cookie 设置 HttpOnly**
    - 防止恶意脚本窃取 Cookie。


消毒：检测到非法输入，提示，或对非法字符进行转换，
httpOnly：禁止攻击者访问cookie，response.setHeader(“Set-Cookie”,”HttpOnly”);
## SQL注入
1.攻击者了解数据库结构
2.公司系统根据开源代码写的
3.错误提示，把jdk堆栈的错误信息提示出去了，使用错误代码
4.攻击者猜不到数据库结构，把关键字转换一下
5.参数绑定，把用户的输入都当成参数使用
## CSRF攻击
1.跨站点访问伪造，
2.常见的 Web 攻击方式。攻击者诱导受害者在已登录某网站的情况下，**在不知情的情况下向该网站发送恶意请求**，从而执行受害者本不想执行的操作。
3.CSRF 攻击原理（简化版）
你登录了网站 A（如银行网站），浏览器保存了登录 Cookie。
攻击者让你访问一个恶意网页 B。
网页 B 静默地向网站 A 发送一个请求（例如转账请求）。
浏览器会自动带上你对网站 A 的 Cookie。
网站 A 以为是你本人发出的请求，于是执行了（转账、修改资料等）。
4.token校验，前后端同时校验，前端将cookie进行加密后发送到后台，后端将cookie进行加密后对比是否相同，不在同一个域名访问的cookie是无效的
5.验证码
6.设置上传文件类型的白名单，上传文件进行重命名，专用的文件服务器
# 网关安全
## 单向加密
1.对输入信息进行散列计算，得到一个固定长度的输出，这个散列计算方式就是单向加密，明文可以加密成密文，密文不能转换成明文
2.单向加密容易被“彩虹表攻击”破解，彩虹表：里面有常用密码明文及密文对照表，因此要加盐：
明文+随机salt==>密文
3.常用算法：
- 经典哈希函数：MD5（旧）、SHA-1（旧）
- 安全哈希函数：SHA-256、SHA-384、SHA-512 
- 密码存储专用（更好）：bcrypt、scrypt、Argon2 
- MD5、SHA-1 已不安全，现在推荐 SHA-256 或 bcrypt / Argon2。
4.场景：
- 接口参数防篡改
- 网站用户密码存储
- 文件完整性校验（MD5/SHA256 校验）
- 数字签名（签名流程需要哈希）    
- 区块链（哈希链结构）
- 证书、消息摘要
## 对称加密
1.加密和解密使用同一个密钥（Key）
2.场景：
- cookie
- 加解密都是服务器在做的
- 文件加密
- 数据库存储加密
- VPN、局域网传输
- TLS 中的大部分数据传输阶段（握手后）
3.算法
- AES，现代标准，最常用、最安全、广泛使用
- DES，旧算法，已不安全（密钥太短）
- 3DES，DES 改进，速度慢，也逐渐废弃
- ChaCha20，流加密，在移动设备表现优秀、轻量快速
- SM4，国密算法，中国国家标准算法
推荐使用 AES 或 ChaCha20。
4.加密流派
1）分组加密（Block Cipher）
固定大小的“块”进行加密（如 128 bit）
代表算法：AES, 3DES
需要加密模式（ECB、CBC、GCM 等）
 2）流加密（Stream Cipher）
像水流一样一位一位加密
代表算法：ChaCha20
5.加解密效率高，可以对大量数据加解密，缺点就是远程通讯情况下，如何安全传输密钥
## 非对称加密
1.公钥，私钥
2.信息安全传输、数字签名
3.私钥加密的信息只能公钥解密，公钥加密的信息只能私钥解密，
4.通过公钥无法计算出私钥
5.信息->单向加密后->摘要A->私钥加密->密文->接收方公钥解密->摘要B->对比摘要A和摘要B是否相同
6.安全性高，效率低
7.先使用非对称加密把密钥传输，用共同知道的密钥进行加解密
8.常用非对称算法RSA
9.密钥写在代码中，或配置文件中
10.对密钥和加密算法放在单独的服务器中，成为瓶颈，系统开销大，
11.将加解密算法放在应用程序中，或通用jar包，但是密钥单独存储，密钥分开存储，mysql+redis+配置文件，把jar包做代码混淆，做加密，或用其它语言做，如C语言，用system引用
## 信息过滤与反垃圾 
1.尽可能收集多用户信息，用户的IP，网络情况，客户端唯一码，imei号
2.可以识别有害信息，有害信息发送方，通过关键词和信息来源来识别垃圾信息
3.对识别出的信息，进行处理，白名单等
4.文本匹配，找出敏感词，lucence做分词处理







